<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
         *创造一个构造函数，专门用于创造Person对象的
         *  构造函数创建方式和普通函数没有区别
         *  但和普通函数调用方式不同
         *      普通函数是直接调用，构造函数需要使用关键字调用
         * 
         *构造函数执行流程
         *  1.立即创建一个新的对象
         *  2.将新建的对象设置为函数中的this，在构造函数中可以使用this引用新建的对象
         *  3.逐行执行函数中代码
         *  4.将新建的对象作为返回值返回
         * 
         *使用同一个构造函数创建的对象，我们称为一类对象，也将构造函数称为一个类
         *      将构造函数创建的对象称为实例
         * 
         *使用instanceof可以检查一个对象是否是一个类的实例
         *      语法：  对象 instanceof 构造函数
         * 
         * 任何对象和Object做instanceof检查时都会返回true
         */
        function Person(name, age){
            this.name = name;
            this.age = age;
            this.getName = function(){
                alert(this.name);
            };
        }
        var per = new Person("张三", 18);
        /*
         *在Person构造函数中，getName方法是内部创建
         *  也就是构造函数每执行一次都会创建一个新的getName方法
         *  也就是所有实例的getName都是唯一的
         *  可以通过将getName在全局作用域中定义使实例共用同一个方法
         *  可以通过将函数定义全局变量进行优化
         *      但污染了全局作用域的命名空间
         *      而且定义在全局作用域中也不安全
         */
        function fun(){
            alert(this.name);
        }
        //修改Person中getName方法为：this.getName = fun;

        /*
         *  原型prototype
         *      我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
         *          这个属性对应着一个对象，这个对象就是原型对象
         *      当函数作为普通函数调用prototype没有任何作用
         *      当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐藏属性
         *          指向该构造函数的原型对象，可以通过__proto__来访问该属性
         * 
         *      原型对象相当于一个公共的区域，同一个类的所有实例都可以访问到原型对象
         *          可以将对象中共有的内容，统一设置到原型对象中
         *      当我们访问一个对象或方法时，会先在对象自身中找，若找到直接使用
         *          没有找到则会去原型中找，找到则使用，没有则去原型的原型中找，直到找到Object的原型
         * 
         *      原型对象也是对象，也有原型。
         *          Object对象的原型没有原型，如果仍未找到，则返回undefined
         */
        Person.prototype.getName = function(){

        }
        /*
         *  使用in检查对象中是否有某个属性时，如果对象中没有但原型中有，也会返回true
         *  可以使用hasOwnProperty()来检查对象自身中是否含有该属性
         *  该方法只要当对象自身中含有属性时才会返回true
         *      该方法在原型的原型里
         */

        /*
         *  当我们直接在页面中打印一个对象时，事实上输出的对象的toString()方法的返回值
         *      在原型的原型里
         *  如果我们希望在输出对象时不输出[object Object],可以为对象添加一个toString()方法
         */

        /*
         *  垃圾回收（GC）
         *      -就像人生活的时间长了会产生垃圾一样,程序运行过程中也会产生垃圾
         *          这些垃圾积攒过多以后,会导致程序运行的速度过慢,
         *          所以我们需要一个垃圾回收的机制,来处理程序运行过程中产生垃圾
         *      当一个对象没有任何的变量或者属性对他进行引用，此时我们将永远无法操作该对象
         *          此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序变慢
         *          所以这种垃圾必须进行清理
         *      在JS中拥有自动的垃圾回收机制，会自动将这些垃圾从内存中销毁
         *          我们不需要也不能进行垃圾回收的操作
         *      我们需要做的只是将不再使用的对象设置成null即可
         */

    </script>
</head>
<body>
    
</body>
</html>